ALTER TABLE gold.dim_products
ALTER COLUMN cost TYPE INTEGER USING cost::integer;


-- Explore all the objects in the database
SELECT * FROM information_schema."tables" ;

-- Explore all columns in the database
SELECT * FROM information_schema."columns"
WHERE table_name = 'dim_customers'

-- Explore all countries our customers are from
SELECT DISTINCT country FROM gold.dim_customers;

-- Explore all major product categories
SELECT DISTINCT category FROM gold.dim_products;

-- Finding the date of the first and last order
-- How many years of sale are available
SELECT 
	MAX(order_date) AS last_order_date,
	MIN(order_date) AS first_order_date,
	EXTRACT(YEAR FROM age(MAX(order_date),MIN(order_date))) AS sales_years
FROM gold.fact_sales fs2 ;

-- Finding the youngest and oldest customers
SELECT  
	MAX(birthdate) AS youngest_birthdate,
	DATE_PART('YEAR', current_date) - DATE_PART('YEAR', MAX(birthdate)) AS youngest_years,
	MIN(birthdate) AS oldest_birthdate,
	DATE_PART('YEAR', current_date) - DATE_PART('YEAR', MIN(birthdate)) 
FROM gold.dim_customers dc;

-- Finding the total sales
SELECT SUM(sales_amount) AS total_sales FROM gold.fact_sales;

-- Finding how many items were sold
SELECT SUM(quantity) AS total_items_sold FROM gold.fact_sales;

-- Finding the average selling price
SELECT AVG(price) AS average_selling_price FROM gold.fact_sales fs2 ;

-- Fidning the total number of orders
SELECT COUNT(order_number) AS num_of_orders FROM gold.fact_sales fs2;
SELECT COUNT(DISTINCT order_number) AS num_of_orders FROM gold.fact_sales fs2;

-- Finding the total number of customers 
SELECT COUNT(customer_id) AS num_of_customers FROM gold.dim_customers;

-- Finding the total number of customers who placed an order
SELECT COUNT(DISTINCT customer_key) AS total_customers_ordered FROM gold.fact_sales fs2;


-- Generate a report that shows all the key metrics of the business
SELECT 'Total Sales' AS measure_name, SUM(sales_amount) AS measure_value FROM gold.fact_sales
UNION ALL 
SELECT 'Total Quantity' AS measure_name, SUM(quantity) AS measure_value FROM gold.fact_sales
UNION ALL 
SELECT 'Average Selling Price' AS measure_name, AVG(price) AS measure_value FROM gold.fact_sales
UNION ALL 
SELECT 'Total Orders' AS measure_name, COUNT(DISTINCT order_number) AS measure_value FROM gold.fact_sales
UNION ALL 
SELECT 'Total Customers' AS measure_name, COUNT(customer_id) AS measure_value FROM gold.dim_customers
UNION ALL 
SELECT 'Total Customers who Ordered' AS measure_name, COUNT(DISTINCT customer_key) AS measure_value FROM gold.fact_sales;


-- MAGNITUDE ANALYSIS(comparing the measure value by categories)
-- Find total customers by countries
SELECT 
	COUNT(customer_id) AS num_customers,
	country 
FROM gold.dim_customers
GROUP BY country
ORDER BY COUNT(customer_id) DESC;

-- Find total customers by gender
SELECT 
	COUNT(customer_id) AS num_customers,
	gender 
FROM gold.dim_customers
GROUP BY gender
ORDER BY COUNT(customer_id) DESC;

-- Find total products by category
SELECT 
	COUNT(product_id) AS num_products,
	category 
FROM gold.dim_products dp
GROUP BY category 
ORDER BY COUNT(product_id) DESC;

-- What is the average costs in each category
SELECT 
	AVG(cost) AS avg_cost,
	category 
FROM gold.dim_products
GROUP BY category 
ORDER BY avg_cost DESC;

-- What is the total revenue generated in each category
SELECT 
	SUM(f.sales_amount) AS total_revenue,
	p.category
FROM gold.fact_sales f 
LEFT JOIN gold.dim_products p 
	ON f.product_key = p.product_key
GROUP BY p.category
ORDER BY total_revenue DESC ;

-- Find the total revenue generated by each customer
SELECT 
	SUM(sales_amount) AS total_revenue,
	customer_key 
FROM gold.fact_sales f
GROUP BY customer_key 
ORDER BY total_revenue DESC;

-- What is the distribution of sold items across countries
SELECT 
	SUM(f.sales_amount) AS total_revenue,
	c.country,
	p.category
FROM gold.fact_sales f
LEFT JOIN gold.dim_customers c 
	ON f.customer_key = c.customer_key
LEFT JOIN gold.dim_products p 
	ON f.product_key = p.product_key
GROUP BY
	c.country,
	p.category
ORDER BY total_revenue DESC;


-- RANKING ANALYSIS
-- Top 5 revenue generating products
SELECT 
	SUM(sales_amount) AS total_revenue,
	p.subcategory  
FROM gold.fact_sales f
LEFT JOIN gold.dim_products p 
	ON f.product_key = p.product_key
GROUP BY subcategory
ORDER BY total_revenue DESC
LIMIT 5;

-- Bottom 5 worst performing products
SELECT 
	SUM(sales_amount) AS total_revenue,
	p.subcategory 
FROM gold.fact_sales f
LEFT JOIN gold.dim_products p 
	ON f.product_key = p.product_key
GROUP BY subcategory 
ORDER BY total_revenue
LIMIT 5;

-- Find the top 10 customers who have generated the highest revenue
SELECT  
	c.first_name,
	c.last_name,
	c.customer_id,
	SUM(f.sales_amount) AS total_revenue
FROM gold.dim_customers c
LEFT JOIN gold.fact_sales f 
	ON c.customer_key = f.customer_key
GROUP BY
	c.first_name,
	c.last_name,
	c.customer_id
ORDER BY total_revenue DESC 
LIMIT 10;

-- Find the bottom 3 customers with fewest orders placed
SELECT  
	c.first_name,
	c.last_name,
	c.customer_id,
	count(DISTINCT order_number) AS total_orders
FROM gold.fact_sales f
LEFT JOIN gold.dim_customers c 
	ON c.customer_key = f.customer_key
GROUP BY
	c.first_name,
	c.last_name,
	c.customer_id
ORDER BY total_orders
LIMIT 3;


--        ADVANCED ANALYTICS      --
-- Changes Over Time Analysis
SELECT 
	EXTRACT(YEAR FROM order_date) AS year,
	EXTRACT(MONTH FROM order_date) AS month,
	sum(sales_amount) AS total_sales,
	count(DISTINCT customer_key) AS total_customer,
	sum(quantity) AS total_quantity
FROM gold.fact_sales f
WHERE order_date IS NOT NULL
GROUP BY EXTRACT(YEAR FROM order_date), EXTRACT(MONTH FROM order_date)
ORDER BY EXTRACT(YEAR FROM order_date), EXTRACT(MONTH FROM order_date);

-- Cumulative Analysis 
-- Calculate the total sales per month and the running total sales per month
SELECT 
	MONTH,
	total_sales,
	SUM(total_sales) OVER(PARTITION BY MONTH ORDER BY MONTH) AS running_total,
	AVG(avg_price) OVER(ORDER BY MONTH) AS moving_average_price
FROM (
	SELECT
		date_trunc('month',order_date) AS MONTH,
		SUM(sales_amount) AS total_sales,
		AVG(price) AS avg_price
	FROM gold.fact_sales
	WHERE date_trunc('month',order_date) IS NOT NULL
	GROUP BY date_trunc('month',order_date)
);

-- Performance Analysis --
/* Analyse the yearly performance of products by comparing each products's sales to both its average sales performance 
 *  and the previous year sales */
WITH yearly_sales AS (
	SELECT 
		p.product_name,
		EXTRACT(YEAR FROM f.order_date) AS YEAR,
		SUM(f.sales_amount) AS current_sales
	FROM gold.fact_sales f
	LEFT JOIN gold.dim_products p
		 ON f.product_key = p.product_key
	WHERE EXTRACT(YEAR FROM f.order_date) IS NOT NULL 
	GROUP BY p.product_name, EXTRACT(YEAR FROM f.order_date)
	ORDER BY EXTRACT(YEAR FROM f.order_date)
)
SELECT 
	YEAR,
	product_name,
	current_sales,
	AVG(current_sales) OVER(PARTITION BY product_name) AS avg_sales,
	current_sales - AVG(current_sales) OVER(PARTITION BY product_name) AS avg_difference,
	CASE WHEN current_sales - AVG(current_sales) OVER(PARTITION BY product_name) > 0 THEN 'Above_Avg'
	     WHEN current_sales - AVG(current_sales) OVER(PARTITION BY product_name) < 0 THEN 'Below_Avg'
	     ELSE 'Avg'
	END AS avg_category,
	LAG(current_sales) OVER(PARTITION BY product_name ORDER BY YEAR) AS prev_year_sales,
	current_sales - LAG(current_sales) OVER(PARTITION BY product_name ORDER BY YEAR) AS diff_year_sales,
	CASE WHEN current_sales - LAG(current_sales) OVER(PARTITION BY product_name ORDER BY YEAR) > 0 THEN 'Above_yearly_performance'
	     WHEN current_sales - LAG(current_sales) OVER(PARTITION BY product_name ORDER BY YEAR) < 0 THEN 'Below_yearly_performance'
	     ELSE 'at_par_performance'
	END AS yearly_performance
FROM yearly_sales
;

-- Which categories contribute the most overall sales
WITH category AS (
	SELECT 
		p.category,
		SUM(sales_amount) AS total_sales
	FROM gold.fact_sales f
	LEFT JOIN gold.dim_products p
		ON f.product_key = p.product_key
	GROUP BY category
)
SELECT 
	category,
	total_sales,
	SUM(total_sales) OVER() AS overall_sales,
	concat(round((total_sales / SUM(total_sales) OVER()) * 100,2),' %') AS percentage_sales 
FROM category;


-- Data Segmentation--
-- Segment Product into cost ranges and count how many products fall into each segment 
WITH cost_segmentation AS (
	SELECT 
		product_key,
		product_name,
		COST,
		CASE WHEN COST <= 500 THEN 'Low Cost'
			 WHEN COST BETWEEN 501 AND 1500 THEN 'Medium Cost'
			 WHEN COST > 1500 THEN 'High Cost'
		     ELSE 'N/A'
		END AS categorization
	FROM gold.dim_products p
)
SELECT 
	categorization,
	count(product_key) AS total_products
FROM cost_segmentation 
GROUP BY categorization
ORDER BY total_products DESC ;

/* GROUP customers INTO 3 categories based ON their spending behaviour: 
     - VIP: Customers WITH atleast 12 months OF history AND spending MORE than 5000
	 - Regular: Customers WITH atleast 12 months OF history but spening less than 5000
	 - NEW: customers WITH a lifespan less than 12 months 
AND find the total numbers OF customers per EACH GROUP */
WITH customer_spending AS (
	SELECT 
		c.customer_key,
		SUM(f.sales_amount) AS total_spending,
		MAX(f.order_date) AS last_order_date,
		MIN(f.order_date) AS first_order_date,
		EXTRACT(MONTH FROM AGE(MAX(f.order_date),MIN(f.order_date))) AS lifespan
	FROM gold.fact_sales f
	LEFT JOIN gold.dim_customers c
		ON f.customer_key = c.customer_key
	GROUP BY c.customer_key
)
SELECT 
	customer_categorization,
	count(customer_key) AS num_customers
FROM (
	SELECT 
		customer_key,
		CASE WHEN total_spending >= 5000 AND lifespan >= 12 THEN 'VIP Customer'
			 WHEN total_spending < 5000 AND lifespan <= 12 THEN 'Regular Customer'
			 WHEN lifespan < 3 THEN 'New Customer'
			 ELSE 'Undefined'
		END AS customer_categorization
	 FROM customer_spending
)
GROUP BY customer_categorization
ORDER BY num_customers DESC; 




